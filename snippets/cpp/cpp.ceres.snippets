snippet ceres
	#include <ceres/ceres.h>

	using ceres::NumericDiffCostFunction;
	using ceres::CostFunction;
	using ceres::Problem;
	using ceres::Solver;
	using ceres::Solve;

	class CostFunctor {
	 public:
		CostFunctor(double k, int size) : k_(k), size_(size) {}

		template <typename T>
		bool operator()(const T* const x, T* err) const {
			${0:// code ...}
			return true;
		}

	 private:
		double k_;
		int size_;
	};

	template <typename T, int SIZE>
	void Solve(T* x, T target) {
		// setup problem
		Problem problem;

		Solver::Options options;
		options.linear_solver_type = ceres::DENSE_QR;
		// options.minimizer_progress_to_stdout = true;
		Solver::Summary summary;
		Solve(options, &problem, &summary);

		// std::cout << summary.BriefReport() << "\n";
		// for (int i = 0; i < SIZE; ++i) {
		//   std::cout << "x[" << i << "] = " << x[i] << '\n';
		// }
	}
snippet ceres include
	#include <ceres/ceres.h>

	using ceres::AutoDiffCostFunction;
	using ceres::CostFunction;
	using ceres::Problem;
	using ceres::Solver;
	using ceres::Solve;
	${0}
snippet ceres autodiff cost function 
	double target = 0;
	CostFunction* ${2:cost_function} =
		new AutoDiffCostFunction<${1:CostFunctor}, 1, SIZE>(
			new CostFunctor(target, SIZE));
	problem.AddResidualBlock(cost_function, NULL, x);
snippet ceres numeric cost function
	CostFunction* ${2:cost_function} =
		new NumericDiffCostFunction<${1:CostFunctor}, ceres::CENTRAL, 1, SIZE>(
			new CostFunctor(target, SIZE));
	problem.AddResidualBlock(cost_function, NULL, x);
snippet ceres solver
	Solver::Options options;
	options.linear_solver_type = ceres::DENSE_QR;
	// options.minimizer_progress_to_stdout = true;
	Solver::Summary summary;
	Solve(options, &problem, &summary);
	// std::cout << summary.BriefReport() << "\n";
	// for (int i = 0; i < SIZE; ++i) {
	//   std::cout << "x[" << i << "] = " << x[i] << '\n';
	// }
