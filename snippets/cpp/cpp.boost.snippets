snippet boost current datetime
	boost::gregorian::date current(boost::gregorian::day_clock::local_day());
	std::stringstream ss;
	ss << current.year() << "/" << current.month() << "/" << current.day();
	${0:std::string current_time = ss.str();}
snippet boost timer
	boost::timer::cpu_timer timer;
	${0:// test code here...}
	std::cout << timer.format() << '\n';
snippet boost shared_ptr
	boost::shared_ptr<${1:int}> ${2:ptr}{new $1${0}};
snippet boost unique_ptr
	boost::unique_ptr<${1:int}> ${2:ptr}{new $1${0}};
snippet boost scope_ptr
	boost::scoped_ptr<${1:int}> ${2:ptr}{new $1${0}};
snippet boost lexical cast
	${1:std::string} ${2:s} = boost::lexical_cast<$1>(${3:0});
## signals2
snippet boost signals2

snippet boost signals2 include
	#include <boost/signals2.hpp>
	#include <boost/bind.hpp>
	${0}
snippet boost signals2 signal
	struct ${1:Functor} {
		void operator()() const {
			${0:// signal code}
		}
	};

	boost::signals2::signal<void()> ${2:sig};
	$2.connect($1());
	$2();
##
## asio
snippet boost asio
	boost::asio::io_service io_service;
snippet boost asio deadline sync timer
	boost::asio::deadline_timer ${1:timer}(io_service);
	$1.expires_from_now(boost::posix_time::seconds(1));
	$1.wait();
snippet boost asio system sync timer
	boost::asio::system_timer ${1:timer}(io_service);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.wait();
snippet boost asio steady sync timer
	boost::asio::steady_timer ${1:timer}(io_service);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.wait();
snippet boost asio high resolution sync timer
	boost::asio::high_resolution_timer ${1:timer}(io_service);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.wait();
snippet boost asio deadline async timer
	boost::asio::deadline_timer ${1:timer}(io);
	$1.expires_from_now(boost::posix_time::seconds(1));
	$1.async_wait([](const boost::system::error_code&) {
		${0:// code ...}
	});
snippet boost asio system async timer
	boost::asio::system_timer ${1:timer}(io);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.async_wait([](const boost::system::error_code&) {
		${0:// code ...}
	});
snippet boost asio steady async timer
	boost::asio::steady_timer ${1:timer}(io);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.async_wait([](const boost::system::error_code&) {
		${0:// code ...}
	});
snippet boost asio high resolution async timer
	boost::asio::high_resolution_timer ${1:timer}(io);
	$1.expires_from_now(std::chrono::seconds(1));
	$1.async_wait([](const boost::system::error_code&) {
		${0:// code ...}
	});
##
## bind
snippet BoostBind
	boost::bind(${1:funcion}, ${2:_1});
##
## mpi
snippet boost mpi
	mpi::environment env;
	mpi::communicator world;
	int r = world.rank();
snippet boost mpi sync send
	world.send(1, 0, ${1:msg});
snippet boost mpi sync recv
	world.recv(1, 1, ${1:msg});
snippet boost mpi async send
	boost::mpi::request req = world.isend(1, 0, ${1:msg});
	boost::mpi::wait_all(req, req + 1);
snippet boost mpi async recv
	boost::mpi::request req = world.irecv(1, 1, ${1:msg});
	boost::mpi::wait_all(req, req + 1);
##
## enable_shared_from_this
snippet boost enabled_shared_from_this
	class ${1:Object} : public boost::enable_shared_from_this<$1> {
	 public:
		$1() {}
		boost::shared_ptr<$1> self() { return shared_from_this(); }
	};
##
## file system
snippet BoostFileSize
	uintmax_t filesize = boost::filesystem::file_size(argv[1]);
snippet BoostFileExists
	boost::filesystem::path p{${1:filepath}};
	if (boost::filesystem::is_regular_file(p)) {
		// found
	} else {
		// not found
	}
snippet BoostDirectoryExists
	boost::filesystem::path p{${1:filepath};
	if (boost::filesystem::is_directory(p)) {
		// found
	} else {
		// not found
	}
snippet BoostIterateDirectory
	boost::filesystem::path p{${1:path};
	if (boost::filesystem::is_directory(p)) {
		for (boost::filesystem::directory_entry& x :
				boost::filesystem::directory_iterator(p))
			// iterate
		}
	}
##
## log
snippet BoostLog
	BOOST_LOG_TRIVIAL(${1:info}) << "${2:log message}";
snippet BoostLogFilter
	boost::log::core::get()->set_filter(boost::log::trivial::severity >=
										boost::log::trivial::info);
snippet BoostLogFile
	namespace logging = boost::log;
	namespace src = boost::log::sources;
	namespace sinks = boost::log::sinks;
	namespace keywords = boost::log::keywords;

	logging::add_file_log(keywords::file_name = "sample_%N.log",
							keywords::rotation_size = 10 * 1024 * 1024,
							keywords::time_based_rotation =
								sinks::file::rotation_at_time_point(0, 0, 0),
							keywords::format = "[%TimeStamp%]: %Message%");
##
## format
snippet BoostFormat
	boost::format("%1%") % "${1:string}"
## program options
snippet BoostProgramOptions
	using namespace boost::program_options;
	options_description desc("${1:Description}");
	desc.add_options()("help,h", "${2:help messages}");

	variables_map vmap;
	store(parse_command_line(argc, argv, desc), vmap);
	notify(vmap);

	if (vmap.count("help")) {
		std::cout << desc << "\n";
		return 0;
	}
	${0}
snippet BoostProgramOptionsAdd
	desc.add_options()("${1:option_name}",
		value<${2:int}>()->default_value(${3:0}), "${4:option help}");

	if (vmap.count("$1")) {
		$2 $1 = vmap["$1"].as<$2>();
		${0:// code here...}
	}
