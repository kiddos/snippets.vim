## header include guard
snippet once
	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}
	#define $1

	${0}

	#endif /* end of include guard: $1 */
## namespace
snippet namespace
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} // end of $1 namespace
##
## Cool Functions
snippet function_fast_inverse_square_root
	float InverseSqrt(float x) {
		float xhalf = 0.5f * x;
		int i = *(int*) &x;
		i = 0x5f3759df - (i >> 1);
		x = *(float*)&i;
		x = x * (1.5f - xhalf * x * x);
		return x;
	}
snippet function_random_init_array
	template <typename T>
	void RandomInitialize(T* A, int size) {
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			A[i] = dist(gen);
		}
	}
snippet function_random_init_vector
	template <typename T>
	void RandomInitialize(std::vector<T>& vec, int size) {
		vec = std::vector<T>(size);
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			vec[i] = dist(gen);
		}
	}
snippet function_quick_sort
	template <typename T>
	int Partition(std::vector<T>& vec, int left, int end) {
		T pivot = vec[left];
		int i = left - 1, j = end + 1;
		while (true) {
			do {
				++i;
			} while (vec[i] < pivot);

			do {
				--j;
			} while (vec[j] > pivot);
			if (i >= j) return j;
			std::swap(vec[j], vec[i]);
		}
	}

	template <typename T>
	void QuickSort(std::vector<T>& vec, int start, int end) {
		if (start < end) {
			int index = Partition(vec, start, end);
			QuickSort(vec, start, index);
			QuickSort(vec, index + 1, end);
		}
	}

	template <typename T>
	void QuickSort(std::vector<T>& vec) {
		QuickSort(vec, 0, vec.size() - 1);
	}
##
## Input/Output
snippet static_if
	#ifndef STATIC_IF_H
	#define STATIC_IF_H

	#include <utility>

	#define FWD(...) std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)

	template <bool Bool>
	using bool_ = std::integral_constant<bool, Bool>;

	template <bool Bool>
	constexpr bool_<Bool> bool_v {};

	template <typename Predicate>
	auto static_if(Predicate) noexcept;

	namespace sf {

	template <bool PredicateResult>
	struct static_if_impl;

	template <typename Function>
	struct static_if_result;

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept;

	template <>
	struct static_if_impl<true> {
	template <typename Function>
	auto& else_(Function&&) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate) noexcept {
		return *this;
	}

	template <typename Function>
	auto then(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}
	};

	template <>
	struct static_if_impl<false> {
	template <typename Function>
	auto& then(Function&& f) noexcept {
		return *this;
	}

	template <typename Function>
	auto else_(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}

	template <typename Predicate>
	auto else_if(Predicate) noexcept {
		return static_if(Predicate{});
	}

	template <typename ...T>
	auto operator()(T&&...) noexcept {}
	};

	template <typename Function>
	struct static_if_result : Function {
	template <typename F>
	static_if_result(F&& f) noexcept : Function(FWD(f)) {}

	template <typename F>
	auto& then(F&& f) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate p) noexcept {
		return *this;
	}

	template <typename F>
	auto& else_(F&&) noexcept {
		return *this;
	}
	};

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept {
	return static_if_result<Function>{FWD(f)};
	}

	} /* end of sf namespace */

	template <typename Predicate>
	auto static_if(Predicate) noexcept {
	return sf::static_if_impl<Predicate{}>{};
	}

	#endif /* end of include guard: STATIC_IF_H */
##
## Class
snippet class
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1&& operator=($1&& $2);
		~$1();

	 private:
		/* fields */
	};

	$1::$1() {}

	$1::$1(const $1& $2) {}

	$1::$1($1&& $2) {}

	$1& $1::operator=(const $1& $2) {
		return *this;
	}

	$1&& $1::operator=($1&& $2) {
		return *this;
	}

	$1::~$1() {}
snippet class_header
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1&& operator=($1&& $2);
		~$1();

	 private:
		${0:/* fields */}
	};
snippet class_implementation
	${1:`Filename('$1')`}::$1() {}

	$1::$1(const $1& $2) {}

	$1::$1($1&& $2) {}

	$1& $1::operator=(const $1& $2) {
		return *this;
	}

	$1&& $1::operator=($1&& $2) {
		return *this;
	}

	$1::~$1() {}
snippet class_template
	template <typename T>
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1& operator=($1&& $2);
		~$1();

	 private:
		${0:/* fields */}
	};

	template <typename T>
	$1<T>::$1() {}

	template <typename T>
	$1<T>::$1(const $1& $2) {}

	template <typename T>
	$1<T>::$1($1&& $2) {}

	template <typename T>
	$1<T>& $1<T>::operator=(const $1& $2) {
		return *this;
	}

	template <typename T>
	$1<T>& $1<T>::operator=($1&& $2) {
		return *this;
	}

	template <typename T>
	$1<T>::~$1() {}
snippet class_template_header
	template <typename T>
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1& operator=($1&& $2);
		~$1();

	 private:
		${0:/* fields */}
	};
snippet class_template_implementation
	template <typename T>
	${1:`Filename('$1')`}<T>::$1() {}

	template <typename T>
	$1<T>::$1(const $1& $2) {}

	template <typename T>
	$1<T>::$1($1&& $2) {}

	template <typename T>
	$1<T>& $1<T>::operator=(const $1& $2) {
		return *this;
	}

	template <typename T>
	$1<T>& $1<T>::operator=($1&& $2) {
		return *this;
	}

	template <typename T>
	$1<T>::~$1() {}
snippet class_exception
	#include <exception>

	class ${1:Exception} : public std::exception {
	 public:
		$1() : msg_("Exception occur") {}
		explicit $1(const char* msg)
			: msg_(msg) {}
		explicit $1(const std::string& msg)
			: msg_(msg) {}
		virtual ~$1() {}
		virtual const char* what() const noexcept {
			return std::string("$1: ") + msg_.c_str();
		}

	 protected:
		std::string msg_;
	};
snippet class_abstract
	class ${1:AbstractClass} {
	 public:
		$1();

	 protected:
		// member declaration
	};
snippet member
	${1:double} ${2:var}_;

	void set_$2(double $2) { $2_ = $2; }
	$1 $2() { return $2_; }
##
## Meta Programming
snippet meta_value
	struct ${1:ValueHolder} {
		enum { value = ${0:0} };
	}
snippet meta_function
	template <int ${2:A}, int ${3:B}>
	struct ${1:Add} {
		enum { result = $2 ${4:+} $3  };
	}
snippet meta_branch
	template <typename ${2:T1}, typename ${3:T2}>
	struct ${1:SameType} {
		enum { result = 0 };
	}

	template <typename T>
	struct $1<T, T> {
		enum { result = 1 };
	}
snippet meta_recursion
	template <unsigned long N>
	struct ${1:Factorial} {
		enum { value = N * $1<N-1>::value };
	}

	template <>
	struct $1<0> {
		enum { value = 1 };
	}
##
## OpenGL
snippet opengl_object
	class ${1:OpenGLObject} {
	 public:
		$1();
		$1(const $1& ${2:`tolower(Filename('$1'))`});
		$1& operator=(const $1& $2);
		~$1();

		void Init();
		bool LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath);
		bool Update();
		void Draw();

	 private:
		bool ReadShaderFile(const std::string& fpath, std::string& content);

		GLuint vao_;
		GLuint vbo_;
		GLuint program_id_;
	};

	$1::$1() : vao_(0), vbo_(0), program_id_(0) {}

	$1::$1(const $1& $2)
			: vao_(triangle.vao_),
				vbo_(triangle.vbo_),
				program_id_(triangle.program_id_) {}

	$1& $1::operator=(const $1& $2) {
		vao_ = triangle.vao_;
		vbo_ = triangle.vbo_;
		program_id_ = triangle.program_id_;
		return *this;
	}

	$1::~$1() {
		glDeleteBuffers(1, &vbo_);
		glDeleteVertexArrays(1, &vao_);
		glDeleteProgram(program_id_);
	}

	void $1::Init() {
		// create vertex array object
		glGenVertexArrays(1, &vao_);
		glBindVertexArray(vao_);

		// create vertex buffer object
		const GLfloat vertex_buffer_data[] = {
			-1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
		};
		glGenBuffers(1, &vbo_);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		// push vertices to OpenGL pipeline
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_buffer_data),
					vertex_buffer_data, GL_STATIC_DRAW);
	}

	bool $1::LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath) {
		// Create the shaders
		GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
		GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);

		// Read the Shader code
		std::string vcode;
		ReadShaderFile(vertex_shader_fpath, vcode);
		std::string fcode;
		ReadShaderFile(fragment_shader_fpath, fcode);

		// Compile Vertex Shader
		const char* const vc = vcode.c_str();
		glShaderSource(vertex_shader_id, 1, &vc, nullptr);
		glCompileShader(vertex_shader_id);

		// Check Vertex Shader
		GLint result = GL_FALSE;
		int info_log_length = 0;
		glGetShaderiv(vertex_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(vertex_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(vertex_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Compile Fragment Shader
		const char* const fc = fcode.c_str();
		glShaderSource(fragment_shader_id, 1, &fc, nullptr);
		glCompileShader(fragment_shader_id);

		// Check Fragment Shader
		glGetShaderiv(fragment_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(fragment_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(fragment_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Link the program
		GLuint program_id = glCreateProgram();
		glAttachShader(program_id, vertex_shader_id);
		glAttachShader(program_id, fragment_shader_id);
		glLinkProgram(program_id);

		// Check the program
		glGetProgramiv(program_id, GL_LINK_STATUS, &result);
		glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetProgramInfoLog(program_id, info_log_length, nullptr, &error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
		}

		glDetachShader(program_id, vertex_shader_id);
		glDetachShader(program_id, fragment_shader_id);

		glDeleteShader(vertex_shader_id);
		glDeleteShader(fragment_shader_id);

		glUseProgram(program_id);
		return true;
	}

	bool Triangle::Update() { return true; }

	void $1::Draw() {
		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
		// Draw the triangle !
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glDisableVertexAttribArray(0);
	}

	bool $1::ReadShaderFile(const std::string& fpath, std::string& content) {
		std::string vertex_shader_code;
		std::ifstream vf(fpath, std::ios::in);
		if (vf.is_open()) {
			std::stringstream ss;
			ss << vf.rdbuf();
			content = ss.str();
			return true;
		} else {
			std::cerr << "ERROR: fail to open " << fpath << '\n';
			return false;
		}
	}
##
## OpenMP
snippet openmp_parallel_for
	#pragma omp parallel for
snippet openmp_macro
	#define OPENMP() _Pragma("omp parallel for")
##
##
## Libtbb
snippet tbb_parallel
	tbb::parallel_for(${1:0}, ${2:size}, ${3:1}, [=](int i) {
		// parallel code
	});

# main
snippet main
	int main(void) {
		// code here...
		return 0;
	}
snippet main_args
	int main(int argc, char* argv[]) {
		// code here...
		return 0;
	}
## SOCI
snippet template_soci_create_sqlite3
	#include <soci/soci.h>
	#include <soci/sqlite3/soci-sqlite3.h>
	#include <exception>
	#include <iostream>
	#include <string>

	using namespace soci;
	using namespace std;

	int main() {
		try {
			session sql(sqlite3, "${1:test.sqlite3}");

			sql << "BEGIN TRANSACTION;";
			sql << "CREATE TABLE IF NOT EXISTS demo("
				<< "id INTEGER PRIMARY KEY AUTOINCREMENT,"
				<< "name TEXT,"
				<< "age INTEGER);";
			// insert data
			for (int i = 0; i < 10000; ++i) {
				string name = "Bob";
				string age = std::to_string(i + 1);
				sql << "INSERT INTO demo(name, age) VALUES(:n, :a);",
					use(name), use(age);
			}
			sql << "COMMIT;";
		} catch (exception const &e) {
			cerr << "Error: " << e.what() << '\n';
		}
		return 0;
	}
snippet template_soci_select_sqlite3
	#include <soci/soci.h>
	#include <soci/sqlite3/soci-sqlite3.h>
	#include <exception>
	#include <iostream>
	#include <string>

	using namespace soci;
	using namespace std;

	int main() {
		try {
			session sql(sqlite3, "${1:test.sqlite3}");

			int count = 0;
			sql << "SELECT COUNT(*) FROM demo;", into(count);
			cout << count << " entries\n";

			std::vector<string> names(10000);
			std::vector<indicator> indicators;

			sql << "SELECT name FROM demo;", into(names, indicators);

			int num_query = names.size();
			for (int i = 0; i < num_query; ++i) {
				if (indicators[i] == i_ok) {
					cout << "name: " << names[i] << '\n';
				}
			}
		} catch (exception const &e) {
			cerr << "Error: " << e.what() << '\n';
		}
		return 0;
	}
