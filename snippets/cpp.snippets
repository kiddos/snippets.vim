## Unicode Symbols
snippet unicode snowman
	u"\u2603";
## header include guard
snippet once
	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}
	#define $1

	${0}

	#endif /* end of include guard: $1 */
snippet include standard io
	#include <iostream>
	#include <iomanip>

	using std::cout;
	using std::cin;
snippet include cuda
	#include <cuda_runtime.h>
	#include <cublas_v2.h>
	#include <cuda.h>
	#include <memory>
snippet include locale
	#include <iostream>
	#include <string>
	#include <locale>
	#include <codecvt>
## namespace
snippet namespace
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* end of $1 namespace */
## Input/Output
snippet cout
	std::cout << ${1} << std::endl;
snippet cin
	std::cin >> ${1};
snippet static_if
	#ifndef STATIC_IF_H
	#define STATIC_IF_H

	#include <utility>

	#define FWD(...) std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)

	template <bool Bool>
	using bool_ = std::integral_constant<bool, Bool>;

	template <bool Bool>
	constexpr bool_<Bool> bool_v {};

	template <typename Predicate>
	auto static_if(Predicate) noexcept;

	namespace sf {

	template <bool PredicateResult>
	struct static_if_impl;

	template <typename Function>
	struct static_if_result;

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept;

	template <>
	struct static_if_impl<true> {
	template <typename Function>
	auto& else_(Function&&) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate) noexcept {
		return *this;
	}

	template <typename Function>
	auto then(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}
	};

	template <>
	struct static_if_impl<false> {
	template <typename Function>
	auto& then(Function&& f) noexcept {
		return *this;
	}

	template <typename Function>
	auto else_(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}

	template <typename Predicate>
	auto else_if(Predicate) noexcept {
		return static_if(Predicate{});
	}

	template <typename ...T>
	auto operator()(T&&...) noexcept {}
	};

	template <typename Function>
	struct static_if_result : Function {
	template <typename F>
	static_if_result(F&& f) noexcept : Function(FWD(f)) {}

	template <typename F>
	auto& then(F&& f) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate p) noexcept {
		return *this;
	}

	template <typename F>
	auto& else_(F&&) noexcept {
		return *this;
	}
	};

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept {
	return static_if_result<Function>{FWD(f)};
	}

	} /* end of sf namespace */

	template <typename Predicate>
	auto static_if(Predicate) noexcept {
	return sf::static_if_impl<Predicate{}>{};
	}

	#endif /* end of include guard: STATIC_IF_H */
## Benchmark
snippet benchmark
	#include <benchmark/benchmark.h>

	static void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			${0:// test code ...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK(${1:BM_Function});

	BENCHMARK_MAIN();
snippet benchmark case basic
	static void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			${0:// test code...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK(${1:BM_Function})
		->Unit(${2:benchmark::kMillisecond})
		->RangeMultiplier(${3:2})
		->Range(8, 8 << 10);
snippet benchmark case template
	template <typename T>
	void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			${0:// test code...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK_TEMPLATE(${1:BM_Template}, int)
		->Unit(${2:benchmark::kMillisecond})
		->RangeMultiplier(${3:2})
		->Range(1 << 0, 8 << 10);
##
## GTest
snippet gtest
	#include <gtest/gtest.h>

	TEST(${1:TestName}, ${2:Description}) {
		${0:// test code...}
	}
snippet gtest test case
	TEST(${1:TestName}, ${2:Description}) {
		${0:// test code...}
	}
##
## Class
snippet class basic
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& ${2:`tolower('$1')`});
		~$1();
		$1& operator=(const $1& ${2:`tolower('$1')`});
		$1& operator=($1&& ${2:`tolower('$1')`});

	 private:
		${0:/* fields */}
	};

	$1::$1() {}

	$1::$1(const $1& $2) {}

	$1::$1($1&& $2) {}

	$1& $1::operator=(const $1& $2) {
		return *this;
	}

	$1& $1::operator=($1&& $2) {
		return *this;
	}

	$1::~$1() {}
snippet class template
	template <typename T>
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1& operator=($1&& $2);
		~$1();

	 private:
		${0:/* fields */}
	};

	template <typename T>
	$1<T>::$1() {}

	template <typename T>
	$1<T>::$1(const $1& $2) {}

	template <typename T>
	$1<T>::$1($1&& $2) {}

	template <typename T>
	$1<T>& $1<T>::operator=(const $1& $2) {
		return *this;
	}

	template <typename T>
	$1<T>& $1<T>::operator=($1&& $2) {
		return *this;
	}

	template <typename T>
	$1<T>::~$1() {}
snippet class exception
	#include <exception>

	class ${1:Exception} : public std::exception {
	 public:
		$1() : msg_("$1") {}
		explicit $1(const char* msg)
			: msg_(std::string("$1: ") + msg) {}
		explicit $1(const std::string& msg)
			: msg_(std::string("CustomException: ") + msg) {}
		virtual ~$1() {}
		virtual const char* what() const noexcept {
			return msg_.c_str();
		}

	 protected:
		std::string msg_;
	};

##
## Common Functions
snippet function random init array
	template <typename T>
	void RandomInitialize(T* A, int size) {
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			A[i] = dist(gen);
		}
	}
snippet function random init vector
	template <typename T>
	void RandomInitialize(std::vector<T>& vec, int size) {
		vec = std::vector<T>(size);
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			vec[i] = dist(gen);
		}
	}
##
## OpenGL
snippet opengl Window
	#include <GL/glew.h>
	#include <GLFW/glfw3.h>
	#include <iostream>

	class ${1:GLWindow} {
	 public:
		$1();
		~$1();
		bool Init();
		void MainLoop();

	 private:
		GLFWwindow* window_;
	};

	$1::$1() : window_(nullptr) {}

	$1::~$1() {
		glfwTerminate();
		// window object will be clean up
	}

	bool $1::Init() {
		// initialize glfw
		if (!glfwInit()) {
			std::cerr << "fail to initialize glfw\n";
			return 1;
		}
		// window setting
		glfwWindowHint(GLFW_SAMPLES, 4);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, ${4:3});
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, ${4:3});
		glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

		// create window
		window_ = glfwCreateWindow(${2:1024}, ${3:756}, "$1", nullptr, nullptr);
		if (!window_) {
			std::cerr
				<< "Failed to open GLFW window. If you have an Intel GPU, they are "
					"not 3.3 compatible. Try the 2.1 version of the tutorials.\n";
			glfwTerminate();
			return false;
		}
		glfwMakeContextCurrent(window_);

		// init glew
		if (glewInit() != GLEW_OK) {
			std::cerr << "Failed to initialize GLEW\n";
			glfwTerminate();
			return false;
		}

		// Ensure we can capture the escape key being pressed below
		glfwSetInputMode(window_, GLFW_STICKY_KEYS, GL_TRUE);
		return true;
	}

	void $1::MainLoop() {
		// Dark blue background
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		do {
			// Clear the screen
			// flickering, so it's there nonetheless.
			glClear(GL_COLOR_BUFFER_BIT);

			// Draw

			// Swap buffers
			glfwSwapBuffers(window_);
			glfwPollEvents();
		} while (!glfwWindowShouldClose(window_));
	}
snippet opengl Object
	#ifndef ${3:`toupper(Filename('$1'))`}_H
	#define $3_H

	#include <GL/glew.h>
	#include <string>
	#include <fstream>
	#include <iostream>
	#include <sstream>

	namespace ${4:gl} {

	class ${1:OpenGLObject} {
	 public:
		$1();
		$1(const $1& ${2:`tolower(Filename('$1'))`});
		$1& operator=(const $1& $2);
		~$1();

		void Init();
		bool LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath);
		bool Update();
		void Draw();

	 private:
		bool ReadShaderFile(const std::string& fpath, std::string& content);

		GLuint vao_;
		GLuint vbo_;
		GLuint program_id_;
	};

	$1::$1() : vao_(0), vbo_(0), program_id_(0) {}

	$1::$1(const $1& $2)
			: vao_(triangle.vao_),
				vbo_(triangle.vbo_),
				program_id_(triangle.program_id_) {}

	$1& $1::operator=(const $1& $2) {
		vao_ = triangle.vao_;
		vbo_ = triangle.vbo_;
		program_id_ = triangle.program_id_;
		return *this;
	}

	$1::~$1() {
		glDeleteBuffers(1, &vbo_);
		glDeleteVertexArrays(1, &vao_);
		glDeleteProgram(program_id_);
	}

	void $1::Init() {
		// create vertex array object
		glGenVertexArrays(1, &vao_);
		glBindVertexArray(vao_);

		// create vertex buffer object
		const GLfloat vertex_buffer_data[] = {
			-1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
		};
		glGenBuffers(1, &vbo_);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		// push vertices to OpenGL pipeline
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_buffer_data),
					vertex_buffer_data, GL_STATIC_DRAW);
	}

	bool $1::LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath) {
		// Create the shaders
		GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
		GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);

		// Read the Shader code
		std::string vcode;
		ReadShaderFile(vertex_shader_fpath, vcode);
		std::string fcode;
		ReadShaderFile(fragment_shader_fpath, fcode);

		// Compile Vertex Shader
		const char* const vc = vcode.c_str();
		glShaderSource(vertex_shader_id, 1, &vc, nullptr);
		glCompileShader(vertex_shader_id);

		// Check Vertex Shader
		GLint result = GL_FALSE;
		int info_log_length = 0;
		glGetShaderiv(vertex_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(vertex_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(vertex_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Compile Fragment Shader
		const char* const fc = fcode.c_str();
		glShaderSource(fragment_shader_id, 1, &fc, nullptr);
		glCompileShader(fragment_shader_id);

		// Check Fragment Shader
		glGetShaderiv(fragment_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(fragment_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(fragment_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Link the program
		GLuint program_id = glCreateProgram();
		glAttachShader(program_id, vertex_shader_id);
		glAttachShader(program_id, fragment_shader_id);
		glLinkProgram(program_id);

		// Check the program
		glGetProgramiv(program_id, GL_LINK_STATUS, &result);
		glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetProgramInfoLog(program_id, info_log_length, nullptr, &error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
		}

		glDetachShader(program_id, vertex_shader_id);
		glDetachShader(program_id, fragment_shader_id);

		glDeleteShader(vertex_shader_id);
		glDeleteShader(fragment_shader_id);

		glUseProgram(program_id);
		return true;
	}

	bool Triangle::Update() { return true; }

	void $1::Draw() {
		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
		// Draw the triangle !
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glDisableVertexAttribArray(0);
	}

	bool $1::ReadShaderFile(const std::string& fpath, std::string& content) {
		std::string vertex_shader_code;
		std::ifstream vf(fpath, std::ios::in);
		if (vf.is_open()) {
			std::stringstream ss;
			ss << vf.rdbuf();
			content = ss.str();
			return true;
		} else {
			std::cerr << "ERROR: fail to open " << fpath << '\n';
			return false;
		}
	}

	} /* end of $2 namespace */

	#endif /* end of include guard: $3_H */
##
## OpenMP
snippet openmp parallel for
	#pragma omp parallel for
# main
snippet main
	int main(void) {
		${0}
		return 0;
	}
snippet main void
	int main(void) {
		return 0;
	}
snippet main with args
	int main(int argc, char* argv[]) {
		return 0;
	}
snippet main with boost program options
	#include <boost/program_options.hpp>
	#include <iostream>

	namespace popt = boost::program_options;

	int main(int argc, char* argv[]) {
		popt::options_description desc("Allowed options");
		desc.add_options()("help,h", "help messages");
		desc.add_options()("input,i",
							popt::value<std::string>()->default_value("input"),
							"input file");
		desc.add_options()("output,o",
							popt::value<std::string>()->default_value("output"),
							"output file");

		popt::variables_map vmap;
		popt::store(popt::parse_command_line(argc, argv, desc), vmap);
		popt::notify(vmap);

		if (vmap.count("help")) {
			std::cout << desc << "\n";
			return 0;
		}

		if (vmap.count("input") && vmap.count("output")) {
			${1:// code...}
		} else {
			${2:// code...}
		}
		return 0;
	}
# ROS
snippet ros publisher
	#include <ros/ros.h>
	#include <std_msgs/String.h>
	#include <sstream>

	int main(int argc, char* argv[]) {
		ros::init(argc, argv, "${1:publisher}");
		ros::NodeHandle node;
		ros::Publisher publisher =
			node.advertise<std_msgs::String>("${2:topic}", ${3:1000});
		ros::Rate loop_rate(${4:10});

		while (ros::ok()) {
			std_msgs::String msg;
			std::stringstream ss;
			msg.data = ss.str();

			ROS_INFO("%s", msg.data.c_str());
			publisher.publish(msg);

			ros::spinOnce();
			loop_rate.sleep();
		}
		return 0;
	}
snippet ros subscriber
	#include <ros/ros.h>
	#include <std_msgs/String.h>

	void Callback(const std_msgs::String::ConstPtr& msg) {
		ROS_INFO("[%s]", msg->data.c_str());
	}

	int main(int argc, char** argv) {
		ros::init(argc, argv, "${1:subscriber}");
		ros::NodeHandle node;
		ros::Subscriber sub = node.subscribe("${2:topic}", ${3:1000}, Callback);
		ros::spin();
		return 0;
	}
snippet ros client
	#include <ros/ros.h>
	#include <$3/$4.h>

	int main(int argc, char** argv) {
		ros::init(argc, argv, "${1:client}");
		ros::NodeHandle node;

		ros::ServiceClient client =
			node.serviceClient<${3:std_srvs}::${4:SetBool}>("${2:topic}");
		$3::$4 srv;
		${5:srv.request.data = true;}
		if (client.call(srv)) {
			ROS_INFO("%d, %s", srv.response.success, srv.response.message);
		} else {
			ROS_ERROR("Fail to call service");
			return 1;
		}
		return 0;
	}
snippet ros server
	#include <ros/ros.h>
	#include <$3/$4.h>

	bool Serve(${3:std_srvs}::${4:SetBool}::Request& req, $3::$4::Response& res) {
		// res.success = true;
		// res.message = "";
		ROS_INFO("request: data=%d", req.data);
		return true;
	}

	int main(int argc, char** argv) {
		ros::init(argc, argv, "${1:server}");
		ros::NodeHandle node;

		ros::ServiceServer service = node.advertiseService("${2:topic}", Serve);
		ROS_INFO("Ready...");
		ros::spin();
		return 0;
	}
#
# sqlite3
snippet sqlite3 connection object
	#ifndef SQLITE_CONNECTION_H
	#define SQLITE_CONNECTION_H

	#include <sqlite3.h>
	#include <iostream>
	#include <string>

	namespace sql {

	class ${1:SqliteConnection} {
	 public:
		$1();
		~$1();
		bool Open(const std::string& db_name);
		void Close();
		bool Exec(const std::string& sql_query);

	 private:
		std::string db_name_;
		sqlite3* db_;
	};

	$1::SqliteConnection() : db_(nullptr) {}

	$1::~$1() {}

	bool $1::Open(const std::string& db_name) {
		db_name_ = db_name;
		int result_code = sqlite3_open(db_name.c_str(), &db_);
		if (result_code) {
			std::cerr << "Can't open database: " << sqlite3_errmsg(db_) << '\n';
			return false;
		} else {
			std::cout << "Opened database successfully\n";
			return true;
		}
	}

	void $1::Close() {
		if (db_) {
			std::cout << "Closing db: " << db_name_;
			sqlite3_close(db_);
		}
	}

	bool SqliteConnection::Exec(const std::string& sql_query,
								sqlite3_callback callback) {
		char* error_msg = nullptr;
		int rc = sqlite3_exec(db_, sql_query.c_str(), callback, 0, &error_msg);
		if (rc != SQLITE_OK) {
			std::cerr << "SQL error: " << error_msg << '\n';
			sqlite3_free(error_msg);
			return false;
		} else {
			std::cout << "Table created successfully";
		}
		return true;
	}

	bool SqliteConnection::Exec(const std::string& sql_query) {
		sqlite3_callback callback = [](void*, int n_cols, char** values,
										char** column_names) -> int {
			for (int i = 0; i < n_cols; ++i) {
			std::cout << column_names[i] << " = " << (values[i] ? values[i] : "NULL")
						<< '\n';
			}
			return 0;
		};
		return Exec(sql_query, callback);
	}

	}  // namespace sql

	#endif /* end of include guard */
##
## Qt
snippet qt simple window
	#include <QApplication>
	#include <QMainWindow>
	#include <QWidget>
	#include <QObject>
	#include <QtWidgets/QMenuBar>
	#include <QtWidgets/QToolBar>
	#include <QtWidgets/QStatusBar>

	namespace ui {

	class MainWindow : public QMainWindow {
		Q_OBJECT

	 public:
		explicit MainWindow(QWidget* parent = nullptr);
		~MainWindow();

		virtual void SetupUI();

	 private:
		QMenuBar* menu_bar_;
		QToolBar* main_tool_bar_;
		QWidget* central_widget_;
		QStatusBar* status_bar_;
	};


	MainWindow::MainWindow(QWidget* parent)
			: QMainWindow(parent),
			menu_bar_(nullptr),
			main_tool_bar_(nullptr),
			central_widget_(nullptr),
			status_bar_(nullptr) {
		SetupUI();
	}

	MainWindow::~MainWindow() {
		if (menu_bar_) delete menu_bar_;
		if (main_tool_bar_) delete main_tool_bar_;
		if (central_widget_) delete central_widget_;
		if (status_bar_) delete status_bar_;
	}

	void MainWindow::SetupUI() {
		resize(400, 300);
		menu_bar_ = new QMenuBar(this);
		menu_bar_->setObjectName(QStringLiteral("menuBar"));
		setMenuBar(menu_bar_);
		main_tool_bar_ = new QToolBar(this);
		main_tool_bar_->setObjectName(QStringLiteral("mainToolBar"));
		addToolBar(main_tool_bar_);
		central_widget_ = new QWidget(this);
		central_widget_->setObjectName(QStringLiteral("centralWidget"));
		setCentralWidget(central_widget_);
		status_bar_ = new QStatusBar(this);
		status_bar_->setObjectName(QStringLiteral("statusBar"));
		setStatusBar(status_bar_);
	}

	} /* end of ui namespace */

	int main(int argc, char* argv[]) {
		QApplication app(argc, argv);
		ui::MainWindow main_window;
		main_window.show();
		return app.exec();
	}
