## Unicode Symbols
snippet unicode snowman
	u"\u2603";
##
## header include guard
snippet once
	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}
	#define $1

	${0}

	#endif /* end of include guard: $1 */
snippet include
	#include <iostream>
	#include <iomanip>

	using std::cout;
	using std::cin;
snippet include cuda
	#include <cuda_runtime.h>
	#include <cublas_v2.h>
	#include <cuda.h>
	#include <memory>
snippet include locale
	#include <iostream>
	#include <string>
	#include <locale>
	#include <codecvt>
## namespace
snippet namespace
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* end of $1 namespace */
##
## Cool Functions
snippet function fast inverse square root
	float InverseSqrt(float x) {
		float xhalf = 0.5f * x;
		int i = *(int*) &x;
		i = 0x5f3759df - (i >> 1);
		x = *(float*)&i;
		x = x * (1.5f - xhalf * x * x);
		return x;
	}
snippet function random init array
	template <typename T>
	void RandomInitialize(T* A, int size) {
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			A[i] = dist(gen);
		}
	}
snippet function random init vector
	template <typename T>
	void RandomInitialize(std::vector<T>& vec, int size) {
		vec = std::vector<T>(size);
		std::mt19937 gen(std::chrono::system_clock::now().time_since_epoch().count());
		std::normal_distribution<T> dist(0, ${1:1.0});
		for (int i = 0; i < size; ++i) {
			vec[i] = dist(gen);
		}
	}
## Input/Output
snippet cout
	std::cout << ${1} << std::endl;
snippet cin
	std::cin >> ${1};
snippet static_if
	#ifndef STATIC_IF_H
	#define STATIC_IF_H

	#include <utility>

	#define FWD(...) std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)

	template <bool Bool>
	using bool_ = std::integral_constant<bool, Bool>;

	template <bool Bool>
	constexpr bool_<Bool> bool_v {};

	template <typename Predicate>
	auto static_if(Predicate) noexcept;

	namespace sf {

	template <bool PredicateResult>
	struct static_if_impl;

	template <typename Function>
	struct static_if_result;

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept;

	template <>
	struct static_if_impl<true> {
	template <typename Function>
	auto& else_(Function&&) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate) noexcept {
		return *this;
	}

	template <typename Function>
	auto then(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}
	};

	template <>
	struct static_if_impl<false> {
	template <typename Function>
	auto& then(Function&& f) noexcept {
		return *this;
	}

	template <typename Function>
	auto else_(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}

	template <typename Predicate>
	auto else_if(Predicate) noexcept {
		return static_if(Predicate{});
	}

	template <typename ...T>
	auto operator()(T&&...) noexcept {}
	};

	template <typename Function>
	struct static_if_result : Function {
	template <typename F>
	static_if_result(F&& f) noexcept : Function(FWD(f)) {}

	template <typename F>
	auto& then(F&& f) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate p) noexcept {
		return *this;
	}

	template <typename F>
	auto& else_(F&&) noexcept {
		return *this;
	}
	};

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept {
	return static_if_result<Function>{FWD(f)};
	}

	} /* end of sf namespace */

	template <typename Predicate>
	auto static_if(Predicate) noexcept {
	return sf::static_if_impl<Predicate{}>{};
	}

	#endif /* end of include guard: STATIC_IF_H */
## Benchmark
snippet benchmark
	#include <benchmark/benchmark.h>

	static void $1(benchmark::State& state) {
		int size = state.range();
		while (state.KeepRunning()) {
			${0:// test code ...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK(${1:BM_Function})
		->Unit(${2:benchmark::kMillisecond})
		->RangeMultiplier(${3:2})
		->Range(8, 8 << 10);

	BENCHMARK_MAIN();
snippet benchmark case basic
	static void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			${0:// test code...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK(${1:BM_Function})
		->Unit(${2:benchmark::kMillisecond})
		->RangeMultiplier(${3:2})
		->Range(8, 8 << 10);
snippet benchmark case template
	template <typename T>
	void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			${0:// test code...}
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK_TEMPLATE(${1:BM_Template}, int)
		->Unit(${2:benchmark::kMillisecond})
		->RangeMultiplier(${3:2})
		->Range(1 << 0, 8 << 10);
##
## Boost
snippet boost current datetime
	boost::gregorian::date current(boost::gregorian::day_clock::local_day());
	std::stringstream ss;
	ss << current.year() << "/" << current.month() << "/" << current.day();
	${0:std::string current_time = ss.str();}
snippet boost timer
	boost::timer::cpu_timer timer;
	${0:// test code here...}
	std::cout << timer.format() << '\n';
snippet boost filepath check
	boost::filesystem::path p{filepath};
	try {
		boost::filesystem::file_status s = status(p);
		if (is_regular_file(s)) {
			${0:// code here...}
		} else {
			${2:throw std::exception();}
		}
	} catch (boost::filesystem::filesystem_error &e) {
		${1:std::cerr << e.what() << '\n';}
	}
snippet boost shared_ptr
	boost::shared_ptr<${1:int}> ${2:ptr}{new $1${0}};
snippet boost unique_ptr
	boost::unique_ptr<${1:int}> ${2:ptr}{new $1${0}};
snippet boost scope_ptr
	boost::scoped_ptr<${1:int}> ${2:ptr}{new $1${0}};
##
## GTest
snippet gtest
	#include <gtest/gtest.h>

	TEST(${1:TestName}, ${2:Description}) {
		${0:// test code...}
	}
snippet gtest test case
	TEST(${1:TestName}, ${2:Description}) {
		${0:// test code...}
	}
##
## Class
snippet class
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		~$1();

	private:
		${0:/* fields */}
	};

	$1::$1() {}

	$1::~$1() {}
snippet class basic
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		~$1();
		$1& operator=(const $1& $2);
		$1& operator=($1&& $2);

	 private:
		${0:/* fields */}
	};

	$1::$1() {}

	$1::$1(const $1& $2) {}

	$1::$1($1&& $2) {}

	$1& $1::operator=(const $1& $2) {
		return *this;
	}

	$1& $1::operator=($1&& $2) {
		return *this;
	}

	$1::~$1() {}
snippet class template
	template <typename T>
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower('$1')`});
		$1($1&& $2);
		$1& operator=(const $1& $2);
		$1& operator=($1&& $2);
		~$1();

	 private:
		${0:/* fields */}
	};

	template <typename T>
	$1<T>::$1() {}

	template <typename T>
	$1<T>::$1(const $1& $2) {}

	template <typename T>
	$1<T>::$1($1&& $2) {}

	template <typename T>
	$1<T>& $1<T>::operator=(const $1& $2) {
		return *this;
	}

	template <typename T>
	$1<T>& $1<T>::operator=($1&& $2) {
		return *this;
	}

	template <typename T>
	$1<T>::~$1() {}
snippet class exception
	#include <exception>

	class ${1:Exception} : public std::exception {
	 public:
		$1() : msg_("$1") {}
		explicit $1(const char* msg)
			: msg_(std::string("$1: ") + msg) {}
		explicit $1(const std::string& msg)
			: msg_(std::string("CustomException: ") + msg) {}
		virtual ~$1() {}
		virtual const char* what() const noexcept {
			return msg_.c_str();
		}

	 protected:
		std::string msg_;
	};
##
## Meta Programming
snippet meta value
	struct ${1:ValueHolder} {
		enum { value = ${0:0} };
	}
snippet meta function
	template <int ${2:A}, int ${3:B}>
	struct ${1:Add} {
		enum { result = $2 ${4:+} $3  };
	}
snippet meta branch
	template <typename ${2:T1}, typename ${3:T2}>
	struct ${1:SameType} {
		enum { result = 0 };
	}

	template <typename T>
	struct $1<T, T> {
		enum { result = 1 };
	}
snippet meta recursion
	template <unsigned long N>
	struct ${1:Factorial} {
		enum { value = N * $1<N-1>::value };
	}

	template <>
	struct $1<0> {
		enum { value = 1 };
	}
##
## OpenGL
snippet opengl Window
	#include <GL/glew.h>
	#include <GLFW/glfw3.h>
	#include <iostream>

	class ${1:GLWindow} {
	 public:
		$1();
		~$1();
		bool Init();
		void MainLoop();

	 private:
		GLFWwindow* window_;
	};

	$1::$1() : window_(nullptr) {}

	$1::~$1() {
		glfwTerminate();
		// window object will be clean up
	}

	bool $1::Init() {
		// initialize glfw
		if (!glfwInit()) {
			std::cerr << "fail to initialize glfw\n";
			return 1;
		}
		// window setting
		glfwWindowHint(GLFW_SAMPLES, 4);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, ${4:3});
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, ${4:3});
		glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

		// create window
		window_ = glfwCreateWindow(${2:1024}, ${3:756}, "$1", nullptr, nullptr);
		if (!window_) {
			std::cerr
				<< "Failed to open GLFW window. If you have an Intel GPU, they are "
					"not 3.3 compatible. Try the 2.1 version of the tutorials.\n";
			glfwTerminate();
			return false;
		}
		glfwMakeContextCurrent(window_);

		// init glew
		if (glewInit() != GLEW_OK) {
			std::cerr << "Failed to initialize GLEW\n";
			glfwTerminate();
			return false;
		}

		// Ensure we can capture the escape key being pressed below
		glfwSetInputMode(window_, GLFW_STICKY_KEYS, GL_TRUE);
		return true;
	}

	void $1::MainLoop() {
		// Dark blue background
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		do {
			// Clear the screen
			// flickering, so it's there nonetheless.
			glClear(GL_COLOR_BUFFER_BIT);

			// Draw

			// Swap buffers
			glfwSwapBuffers(window_);
			glfwPollEvents();
		} while (!glfwWindowShouldClose(window_));
	}
snippet opengl Object
	#ifndef ${3:`toupper(Filename('$1'))`}_H
	#define $3_H

	#include <GL/glew.h>
	#include <string>
	#include <fstream>
	#include <iostream>
	#include <sstream>

	namespace ${4:gl} {

	class ${1:OpenGLObject} {
	 public:
		$1();
		$1(const $1& ${2:`tolower(Filename('$1'))`});
		$1& operator=(const $1& $2);
		~$1();

		void Init();
		bool LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath);
		bool Update();
		void Draw();

	 private:
		bool ReadShaderFile(const std::string& fpath, std::string& content);

		GLuint vao_;
		GLuint vbo_;
		GLuint program_id_;
	};

	$1::$1() : vao_(0), vbo_(0), program_id_(0) {}

	$1::$1(const $1& $2)
			: vao_(triangle.vao_),
				vbo_(triangle.vbo_),
				program_id_(triangle.program_id_) {}

	$1& $1::operator=(const $1& $2) {
		vao_ = triangle.vao_;
		vbo_ = triangle.vbo_;
		program_id_ = triangle.program_id_;
		return *this;
	}

	$1::~$1() {
		glDeleteBuffers(1, &vbo_);
		glDeleteVertexArrays(1, &vao_);
		glDeleteProgram(program_id_);
	}

	void $1::Init() {
		// create vertex array object
		glGenVertexArrays(1, &vao_);
		glBindVertexArray(vao_);

		// create vertex buffer object
		const GLfloat vertex_buffer_data[] = {
			-1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
		};
		glGenBuffers(1, &vbo_);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		// push vertices to OpenGL pipeline
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_buffer_data),
					vertex_buffer_data, GL_STATIC_DRAW);
	}

	bool $1::LoadShaders(const std::string& vertex_shader_fpath,
						const std::string& fragment_shader_fpath) {
		// Create the shaders
		GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
		GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);

		// Read the Shader code
		std::string vcode;
		ReadShaderFile(vertex_shader_fpath, vcode);
		std::string fcode;
		ReadShaderFile(fragment_shader_fpath, fcode);

		// Compile Vertex Shader
		const char* const vc = vcode.c_str();
		glShaderSource(vertex_shader_id, 1, &vc, nullptr);
		glCompileShader(vertex_shader_id);

		// Check Vertex Shader
		GLint result = GL_FALSE;
		int info_log_length = 0;
		glGetShaderiv(vertex_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(vertex_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(vertex_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Compile Fragment Shader
		const char* const fc = fcode.c_str();
		glShaderSource(fragment_shader_id, 1, &fc, nullptr);
		glCompileShader(fragment_shader_id);

		// Check Fragment Shader
		glGetShaderiv(fragment_shader_id, GL_COMPILE_STATUS, &result);
		glGetShaderiv(fragment_shader_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetShaderInfoLog(fragment_shader_id, info_log_length, nullptr,
							&error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
			return false;
		}

		// Link the program
		GLuint program_id = glCreateProgram();
		glAttachShader(program_id, vertex_shader_id);
		glAttachShader(program_id, fragment_shader_id);
		glLinkProgram(program_id);

		// Check the program
		glGetProgramiv(program_id, GL_LINK_STATUS, &result);
		glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &info_log_length);
		if (!result && info_log_length > 0) {
			std::string error_msg(info_log_length + 1, ' ');
			glGetProgramInfoLog(program_id, info_log_length, nullptr, &error_msg[0]);
			std::cerr << "ERROR: " << error_msg << '\n';
		}

		glDetachShader(program_id, vertex_shader_id);
		glDetachShader(program_id, fragment_shader_id);

		glDeleteShader(vertex_shader_id);
		glDeleteShader(fragment_shader_id);

		glUseProgram(program_id);
		return true;
	}

	bool Triangle::Update() { return true; }

	void $1::Draw() {
		glEnableVertexAttribArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, vbo_);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
		// Draw the triangle !
		glDrawArrays(GL_TRIANGLES, 0, 3);
		glDisableVertexAttribArray(0);
	}

	bool $1::ReadShaderFile(const std::string& fpath, std::string& content) {
		std::string vertex_shader_code;
		std::ifstream vf(fpath, std::ios::in);
		if (vf.is_open()) {
			std::stringstream ss;
			ss << vf.rdbuf();
			content = ss.str();
			return true;
		} else {
			std::cerr << "ERROR: fail to open " << fpath << '\n';
			return false;
		}
	}

	} /* end of $2 namespace */

	#endif /* end of include guard: $3_H */
##
## OpenMP
snippet openmp parallel for
	#pragma omp parallel for
snippet openmp macro
	#define OPENMP() _Pragma("omp parallel for")
##
## OpenCV
snippet opencv3 camera
	#include <opencv2/core.hpp>
	#include <opencv2/highgui.hpp>
	#include <opencv2/videoio.hpp>

	class ${1:Camera} {
	 public:
		$1() : cam_(0) {}
		$1(int device) : cam_(device) {}

		void Run() {
			while (true) {
				cv::Mat cam_image;
				cam_.read(cam_image);

				cv::imshow("$1", cam_image);
				char key = cv::waitKey(10);
				if (key == 'q' || key == 'Q' || key == 27) {
					break;
				}
			}
		}

	 private:
		cv::VideoCapture cam_;
	};

	int main(void) {
		$1 cam;
		cam.Run();
		return 0;
	}
##
## Libtbb
snippet tbb parallel
	tbb::parallel_for(${1:0}, ${2:size}, ${3:1}, [=](int i) {
		${0:// parallel code...}
	});

# main
snippet main
	int main(void) {
		${0}
		return 0;
	}
snippet main args
	int main(int argc, char* argv[]) {
		return 0;
	}
snippet main boost program options
	#include <boost/program_options.hpp>
	#include <iostream>

	namespace popt = boost::program_options;

	int main(int argc, char* argv[]) {
		popt::options_description desc("Allowed options");
		desc.add_options()("help,h", "help messages");
		desc.add_options()("input,i",
							popt::value<std::string>()->default_value("input"),
							"input file");
		desc.add_options()("output,o",
							popt::value<std::string>()->default_value("output"),
							"output file");

		popt::variables_map vmap;
		popt::store(popt::parse_command_line(argc, argv, desc), vmap);
		popt::notify(vmap);

		if (vmap.count("help")) {
			std::cout << desc << "\n";
			return 0;
		}

		if (vmap.count("input") && vmap.count("output")) {
			${1:// code...}
		} else {
			${2:// code...}
		}
		return 0;
	}
snippet main glog
	#include <glog/logging.h>

	int main(int argc, char** argv) {
		google::InitGoogleLogging(argv[0]);
		return 0;
	}
snippet main basic
	#include <iostream>
	#include <iomanip>

	using std::cout;
	using std::cin;

	int main(void) {
		${0}
		return 0;
	}
# ROS
snippet ros publisher
	#include <ros/ros.h>
	#include <std_msgs/String.h>
	#include <sstream>

	class Publisher {
	 public:
		Publisher() : pub_(node_.advertise<std_msgs::String>("topic", 1000)) {}

		void Run() {
			ros::Rate loop_rate(10);
			while (ros::ok()) {
			std_msgs::String msg;
			std::stringstream ss;
			msg.data = ss.str();

			ROS_INFO("%s", msg.data.c_str());
			pub_.publish(msg);

			ros::spinOnce();
			loop_rate.sleep();
			}
		}

	 private:
		ros::NodeHandle node_;
		ros::Publisher pub_;
	};

	int main(int argc, char* argv[]) {
		ros::init(argc, argv, "publisher");
		Publisher pub;
		pub.Run();
		return 0;
	}
snippet ros subscriber
	#include <ros/ros.h>
	#include <std_msgs/String.h>

	class ${1:Listener} {
	 public:
		$1() : sub_(node_.subscribe("${2:topic}", ${3:1000}, &$1::Callback, this)) {}
		void Run() { ros::spin(); }

	 private:
		void Callback(const std_msgs::String::ConstPtr& msg) {
			ROS_INFO("[%s]", msg->data.c_str());
			${0}
		}
		ros::NodeHandle node_;
		ros::Subscriber sub_;
	};

	int main(int argc, char** argv) {
		ros::init(argc, argv, "subscriber");
		$1 ${4:listener};
		$4.Run();
		return 0;
	}
snippet ros client
	#include <ros/ros.h>
	#include <std_srvs/SetBool.h>

	class ${1:Client} {
	 public:
		$1() : client_(node_.serviceClient<std_srvs::SetBool>("${2:topic}")) {}

		void Call() {
			std_srvs::SetBool srv;
			srv.request.data = true;
			if (client_.call(srv)) {
				ROS_INFO("[%d]", srv.response.success);
			} else {
				ROS_ERROR("Fail to call service");
			}
		}

		void Run() {
			ros::Rate loop_rate(10);
			while (ros::ok()) {
				Call();
				ros::spinOnce();
				loop_rate.sleep();
			}
		}

	 private:
		ros::NodeHandle node_;
		ros::ServiceClient client_;
	};

	int main(int argc, char** argv) {
		ros::init(argc, argv, "client");

		$1 ${3:client};
		$3.Call();
		// $3.Run();
		return 0;
	}
snippet ros server
	#include <ros/ros.h>
	#include <std_srvs/SetBool.h>
	#include <thread>

	class Server {
	 public:
		Server() : service_(node_.advertiseService("topic", &Server::Serve, this)) {}

		bool Serve(std_srvs::SetBool::Request& req, std_srvs::SetBool::Response& res) {
			ROS_INFO("request: data=%d", req.data);
			return true;
		}

		void Run () {
			ROS_INFO("Ready...");
			ros::spin();
		}

	 private:
		ros::NodeHandle node_;
		ros::ServiceServer service_;
	};

	int main(int argc, char** argv) {
		ros::init(argc, argv, "server");

		Server server;
		server.Run();
		return 0;
	}
##
## sqlite3
snippet sqlite3 connection
	#include <sqlite3.h>
	#include <cassert>
	#include <iostream>
	#include <map>
	#include <sstream>
	#include <string>
	#include <tuple>
	#include <utility>
	#include <vector>

	namespace ${2:sql} {

	class ${1:SqliteConnection} {
	 public:
		$1();
		~$1();
		bool Open(const std::string& db_name);
		void Close();
		// basic execution
		bool Exec(const std::string& sql_query, sqlite3_callback callback,
					void* data);
		bool Exec(const std::string& sql_query);
		// transaction
		bool BeginTransaction();
		bool Commit();
		// create table
		bool CreateTable(const std::string& table_name);
		template <typename... Args>
		bool CreateTable(const std::string& table_name,
						const std::string& column_name, Args... args) {
			if (ss_.str() != "") ss_ << ", ";
			ss_ << column_name;
			return CreateTable(table_name, args...);
		}
		// insert
		bool Insert(const std::string& table_name,
					const std::vector<std::string>& column_names);
		template <typename T, typename... Args>
		bool Insert(const std::string& table_name,
					const std::vector<std::string>& column_names, T col_entry,
					Args... args) {
			if (ss_.str() != "") ss_ << ", ";
			ss_ << col_entry;
			return Insert(table_name, column_names, args...);
		}
		bool SelectAll(const std::string& table_name,
						std::vector<std::map<std::string, std::string>>& entries);
		bool SelectWhere(const std::string& table_name,
						std::vector<std::map<std::string, std::string>>& entries,
						const std::string& where_clause);
		template <typename T>
		bool Update(const std::string& table_name, const std::string& column_name,
					T new_value, const std::string& where_clause) {
			std::stringstream query;
			query << "UPDATE " << table_name << " set " << column_name << " = "
				<< new_value << " WHERE " << where_clause << ";";
			return Exec(query.str());
		}
		bool Delete(const std::string& table_name, const std::string& where_clause) {
			std::stringstream query;
			query << "DELETE from " << table_name << " WHERE " << where_clause << ";";
			return Exec(query.str());
		}

		void set_verbose(bool verbose) { verbose_ = verbose; }

	 private:
		bool verbose_;
		std::stringstream ss_;
		std::string db_name_;
		sqlite3* db_;
	};

	}

	namespace $2 {

	using std::vector;
	using std::string;

	$1::$1() : verbose_(false), db_(nullptr) {}

	$1::~$1() { Close(); }

	bool $1::Exec(const string& sql_query) {
		return Exec(sql_query, nullptr, nullptr);
	}

	bool $1::Exec(const string& sql_query, sqlite3_callback callback,
								void* data) {
		char* error_msg = nullptr;
		int rc = sqlite3_exec(db_, sql_query.c_str(), callback, data, &error_msg);
		if (rc != SQLITE_OK) {
			if (verbose_) {
				std::cerr << "SQL error: " << error_msg << '\n';
			}
			sqlite3_free(error_msg);
			return false;
		}
		return true;
	}

	bool $1::Open(const string& db_name) {
		db_name_ = db_name;
		int result_code = sqlite3_open(db_name.c_str(), &db_);
		if (result_code) {
			if (verbose_) {
				std::cerr << "Can't open database: " << sqlite3_errmsg(db_) << '\n';
			}
			return false;
		}
		return true;
	}

	void $1::Close() {
		if (db_) {
			if (verbose_) {
				std::cout << "Closing db: " << db_name_;
			}
			sqlite3_close(db_);
			db_ = nullptr;
		}
	}

	bool $1::BeginTransaction() { return Exec("BEGIN TRANSACTION"); }

	bool $1::Commit() { return Exec("COMMIT"); }

	bool $1::CreateTable(const string& table_name) {
		std::string columns = ss_.str();
		std::stringstream query;
		query << "CREATE TABLE IF NOT EXISTS " << table_name << "(" << columns
				<< ");";
		bool result = Exec(query.str());

		// clear string stream
		ss_.str("");
		return result;
	}

	bool $1::Insert(const string& table_name,
								const vector<string>& column_names) {
		std::stringstream query;
		query << "INSERT INTO " << table_name << "(";
		int num_columns = column_names.size();
		for (int i = 0; i < num_columns; ++i) {
			if (i != 0) query << ", ";
			query << column_names[i];
		}
		query << ") VALUES(" << ss_.str() << ");";

		// clear string stream
		ss_.str("");
		return Exec(query.str());
	}

	bool $1::SelectAll(const string& table_name,
									vector<std::map<string, string>>& entries) {
		auto query_func = [](void* data, int n_cols, char** values,
							char** column_names) -> int {
			vector<std::map<string, string>>* data_collection =
				(vector<std::map<string, string>>*)(data);
			// create autocaststring vec
			std::map<string, string> m;
			for (int i = 0; i < n_cols; ++i) {
			m[column_names[i]] = values[i];
			}
			data_collection->push_back(m);
			return 0;
		};

		std::stringstream query;
		query << "SELECT * FROM " << table_name << ";";
		return Exec(query.str(), query_func, &entries);
	}

	bool $1::SelectWhere(const string& table_name,
									vector<std::map<string, string>>& entries,
									const string& where_clause) {
		auto query_func = [](void* data, int n_cols, char** values,
							char** column_names) -> int {
			vector<std::map<string, string>>* data_collection =
				(vector<std::map<string, string>>*)(data);
			// create autocaststring vec
			std::map<string, string> m;
			for (int i = 0; i < n_cols; ++i) {
			m[column_names[i]] = values[i];
			}
			data_collection->push_back(m);
			return 0;
		};

		std::stringstream query;
		query << "SELECT * FROM " << table_name << " WHERE " << where_clause << ";";
		return Exec(query.str(), query_func, &entries);
	}

	}  // namespace sql
##
## Qt
snippet qt simple window
	#include <QApplication>
	#include <QMainWindow>
	#include <QWidget>
	#include <QObject>
	#include <QtWidgets/QMenuBar>
	#include <QtWidgets/QToolBar>
	#include <QtWidgets/QStatusBar>

	namespace ui {

	class MainWindow : public QMainWindow {
		Q_OBJECT

	 public:
		explicit MainWindow(QWidget* parent = nullptr);
		~MainWindow();

		virtual void SetupUI();

	 private:
		QMenuBar* menu_bar_;
		QToolBar* main_tool_bar_;
		QWidget* central_widget_;
		QStatusBar* status_bar_;
	};


	MainWindow::MainWindow(QWidget* parent)
			: QMainWindow(parent),
			menu_bar_(nullptr),
			main_tool_bar_(nullptr),
			central_widget_(nullptr),
			status_bar_(nullptr) {
		SetupUI();
	}

	MainWindow::~MainWindow() {
		if (menu_bar_) delete menu_bar_;
		if (main_tool_bar_) delete main_tool_bar_;
		if (central_widget_) delete central_widget_;
		if (status_bar_) delete status_bar_;
	}

	void MainWindow::SetupUI() {
		resize(400, 300);
		menu_bar_ = new QMenuBar(this);
		menu_bar_->setObjectName(QStringLiteral("menuBar"));
		setMenuBar(menu_bar_);
		main_tool_bar_ = new QToolBar(this);
		main_tool_bar_->setObjectName(QStringLiteral("mainToolBar"));
		addToolBar(main_tool_bar_);
		central_widget_ = new QWidget(this);
		central_widget_->setObjectName(QStringLiteral("centralWidget"));
		setCentralWidget(central_widget_);
		status_bar_ = new QStatusBar(this);
		status_bar_->setObjectName(QStringLiteral("statusBar"));
		setStatusBar(status_bar_);
	}

	} /* end of ui namespace */

	int main(int argc, char* argv[]) {
		QApplication app(argc, argv);
		ui::MainWindow main_window;
		main_window.show();
		return app.exec();
	}
##
## SOCI
snippet soci create sqlite3
	#include <soci/soci.h>
	#include <soci/sqlite3/soci-sqlite3.h>
	#include <exception>
	#include <iostream>
	#include <string>

	using namespace soci;
	using namespace std;

	int main() {
		try {
			session sql(sqlite3, "${1:test.sqlite3}");

			sql << "BEGIN TRANSACTION;";
			sql << "CREATE TABLE IF NOT EXISTS demo("
				<< "id INTEGER PRIMARY KEY AUTOINCREMENT,"
				<< "name TEXT,"
				<< "age INTEGER);";
			// insert data
			for (int i = 0; i < 10000; ++i) {
				string name = "Bob";
				string age = std::to_string(i + 1);
				sql << "INSERT INTO demo(name, age) VALUES(:n, :a);",
					use(name), use(age);
			}
			sql << "COMMIT;";
		} catch (exception const &e) {
			cerr << "Error: " << e.what() << '\n';
		}
		return 0;
	}
snippet soci select sqlite3
	#include <soci/soci.h>
	#include <soci/sqlite3/soci-sqlite3.h>
	#include <exception>
	#include <iostream>
	#include <string>

	using namespace soci;
	using namespace std;

	int main() {
		try {
			session sql(sqlite3, "${1:test.sqlite3}");

			int count = 0;
			sql << "SELECT COUNT(*) FROM demo;", into(count);
			cout << count << " entries\n";

			std::vector<string> names(10000);
			std::vector<indicator> indicators;

			sql << "SELECT name FROM demo;", into(names, indicators);

			int num_query = names.size();
			for (int i = 0; i < num_query; ++i) {
				if (indicators[i] == i_ok) {
					cout << "name: " << names[i] << '\n';
				}
			}
		} catch (exception const &e) {
			cerr << "Error: " << e.what() << '\n';
		}
		return 0;
	}
##
## ceres solver
snippet ceres autodiff
	#include <ceres/ceres.h>

	using ceres::AutoDiffCostFunction;
	using ceres::CostFunction;
	using ceres::Problem;
	using ceres::Solver;
	using ceres::Solve;

	class CostFunctor {
	 public:
		CostFunctor(double k, int size) : k_(k), size_(size) {}

		template <typename T>
		bool operator()(const T* const x, T* err) const {
			err[0] = T(0);
			for (int i = 0; i < size_; ++i) {
				err[0] += (T(k_) - x[i]);
			}
			return true;
		}

	 private:
		double k_;
		int size_;
	};

	template <typename T, int SIZE>
	void Solve(T* x, T target) {
		// setup problem
		Problem problem;
		CostFunction* cost_function =
			new AutoDiffCostFunction<CostFunctor, 1, SIZE>(
				new CostFunctor(target, SIZE));
		problem.AddResidualBlock(cost_function, NULL, x);

		// Run the solver!
		Solver::Options options;
		options.linear_solver_type = ceres::DENSE_QR;
		// options.minimizer_progress_to_stdout = true;
		Solver::Summary summary;
		Solve(options, &problem, &summary);

		// std::cout << summary.BriefReport() << "\n";
		// for (int i = 0; i < SIZE; ++i) {
		//   std::cout << "x[" << i << "] = " << x[i] << '\n';
		// }
	}
snippet ceres numeric
	#include <ceres/ceres.h>

	using ceres::NumericDiffCostFunction;
	using ceres::CostFunction;
	using ceres::Problem;
	using ceres::Solver;
	using ceres::Solve;

	class CostFunctor {
	 public:
		CostFunctor(double k, int size) : k_(k), size_(size) {}

		template <typename T>
		bool operator()(const T* const x, T* err) const {
			err[0] = T(0);
			for (int i = 0; i < size_; ++i) {
				err[0] += (T(k_) - x[i]);
			}
			return true;
		}

	 private:
		double k_;
		int size_;
	};

	template <typename T, int SIZE>
	void Solve(T* x, T target) {
		// setup problem
		Problem problem;
		CostFunction* cost_function =
			new NumericDiffCostFunction<CostFunctor, ceres::CENTRAL, 1, SIZE>(
				new CostFunctor(target, SIZE));
		problem.AddResidualBlock(cost_function, NULL, x);

		// Run the solver!
		Solver::Options options;
		options.linear_solver_type = ceres::DENSE_QR;
		// options.minimizer_progress_to_stdout = true;
		Solver::Summary summary;
		Solve(options, &problem, &summary);

		// std::cout << summary.BriefReport() << "\n";
		// for (int i = 0; i < SIZE; ++i) {
		//   std::cout << "x[" << i << "] = " << x[i] << '\n';
		// }
	}
