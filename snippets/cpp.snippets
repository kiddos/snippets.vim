extends c
# Class
snippet class simple
	class ${1:`Filename('$1')`} {
	 public:
		$1();

	 private:
		${0:/* fields */}
	};
snippet class full
	class ${1:`Filename('$1')`} {
	 public:
		$1();
		$1(const $1& ${2:`tolower(Filename('$1'))`});
		$1& operator= (const $1& ${2:`tolower(Filename('$1'))`});
		~$1();

	 private:
		${0:/* fields */}
	};
# namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* end of $1 namespace */
snippet namespace
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* end of $1 namespace */
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
snippet test
	TEST(${1:TestName}, ${2:Description}) {
		// test code
	}
snippet static_if
	#ifndef STATIC_IF_H
	#define STATIC_IF_H

	#include <utility>

	#define FWD(...) std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)

	template <bool Bool>
	using bool_ = std::integral_constant<bool, Bool>;

	template <bool Bool>
	constexpr bool_<Bool> bool_v {};

	template <typename Predicate>
	auto static_if(Predicate) noexcept;

	namespace sf {

	template <bool PredicateResult>
	struct static_if_impl;

	template <typename Function>
	struct static_if_result;

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept;

	template <>
	struct static_if_impl<true> {
	template <typename Function>
	auto& else_(Function&&) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate) noexcept {
		return *this;
	}

	template <typename Function>
	auto then(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}
	};

	template <>
	struct static_if_impl<false> {
	template <typename Function>
	auto& then(Function&& f) noexcept {
		return *this;
	}

	template <typename Function>
	auto else_(Function&& f) noexcept {
		return make_static_if_result(FWD(f));
	}

	template <typename Predicate>
	auto else_if(Predicate) noexcept {
		return static_if(Predicate{});
	}

	template <typename ...T>
	auto operator()(T&&...) noexcept {}
	};

	template <typename Function>
	struct static_if_result : Function {
	template <typename F>
	static_if_result(F&& f) noexcept : Function(FWD(f)) {}

	template <typename F>
	auto& then(F&& f) noexcept {
		return *this;
	}

	template <typename Predicate>
	auto& else_if(Predicate p) noexcept {
		return *this;
	}

	template <typename F>
	auto& else_(F&&) noexcept {
		return *this;
	}
	};

	template <typename Function>
	auto make_static_if_result(Function&& f) noexcept {
	return static_if_result<Function>{FWD(f)};
	}

	} /* end of sf namespace */

	template <typename Predicate>
	auto static_if(Predicate) noexcept {
	return sf::static_if_impl<Predicate{}>{};
	}

	#endif /* end of include guard: STATIC_IF_H */
# template
snippet template class header
	#ifndef ${1:`toupper(Filename('$1'))`}_H
	#define $1_H

	class ${2:`Filename('$1')`} {
	 public:
		$2();

	 private:
		${3:/* fields */}
	};

	#endif /* end of include guard: $1 */
snippet template c++ basic
	#include <iostream>

	using std::cout;

	int main(int argc, char** argv) {
		return 0;
	}
snippet template c++ cuda
	#include <cuda_runtime.h>
	#include <cublas_v2.h>
	#include <iostream>
	#include <memory>

	using std::cout;

	int main(int argc, char** argv) {
		return 0;
	}
snippet template benchmark
	#include <benchmark/benchmark.h>

	static void $1(benchmark::State& state) {
		while (state.KeepRunning()) {
			// test code ...
		}
		state.SetBytesProcessed(int64_t(state.iterations()) *
								int64_t(state.range(0)));
	}

	BENCHMARK(${1:BM_Function});

	BENCHMARK_MAIN();
snippet template gtest
	#include <gtest/gtest.h>

	TEST(${1:TestName}, ${2:Description}) {
		EXPECT_EQ(${3:true});
	}
snippet template exception
	#include <exception>

	class ${1:Exception} : public std::exception {
	 public:
		$1() : msg_("$1") {}
		explicit $1(const char* msg)
		: msg_(std::string("$1: ") + msg) {}
		explicit $1(const std::string& msg)
		: msg_(std::string("CustomException: ") + msg) {}
		virtual ~$1() {}
		virtual const char* what() const noexcept {
		return msg_.c_str();
		}

	 protected:
		std::string msg_;
	};
